#lang racket/base
(provide
 compile-template)

(require
 (prefix-in mt: "../ast/metaterm.rkt")
 "../ast/decl.rkt"
 "../repr/ids.rkt"
 (for-template racket/base)
 (only-in racket/syntax generate-temporary format-id)
 (only-in racket/function curry)
 racket/list
 racket/match
 syntax/parse)

;; =======================================================================================

;; -------------
;; Intermediate representation for code generated by templates
;; -------------

;; ir ::=
;;   | (ir:bind id stx ir)
;;   | (ir:check stx spec nat ir)
;;   | ir:expr
;;
;; ir:expr ::=
;;   | (ir:prod production [listof ir:expr])
;;   | (ir:append ir:expr ir:expr)
;;   | (ir:values [listof ir:expr])
;;   | (ir:for [listof ir:for-clause] ir:expr [listof id] ir:expr)
;;   | identifier
;;   | #'(quote <any>)

(struct ir:bind (id stx body) #:transparent)
(struct ir:check (stx spec depth body) #:transparent)
(struct ir:prod (prod args) #:transparent)
(struct ir:cons (head tail) #:transparent)
(struct ir:append (front back) #:transparent)
(struct ir:values (exprs) #:transparent)
(struct ir:for (for-clauses loop-expr list-ids body) #:transparent)

(struct ir:for-clause (id list-stx) #:transparent)

(define ir:empty #''())

(define (ir:auto-append front back)
  (if (equal? back ir:empty)
    front
    (ir:append front back)))

(define (ir:auto-values exprs)
  (match exprs
    [(list expr) expr]
    [_ (ir:values exprs)]))

;; --------------------
;; inside-out context to describe iteration variables
;; --------------------
;;
;; For instance, a pass at ellipsis-depth 2 may return this ctx:
;;   (for-loop {y x} (for-loop {x mylist} #f))
;; along with these immediates:
;;   (list #'y #''0)
;; This could be hypothetically transformed into this code:
;;   (for ([x mylist])
;;     (for ([y x])
;;        (values y '0)))
;;
;; Notice that the innermost clause is {y x}, but that was the outmost ctx:for-loop --
;; this is intentional, and it's why I'm calling it "inside-out". This way, we can peel
;; off layers of ctx:for-loop in order to incrementally add layers to the innermost
;; syntax.
;; --------------------

;; loop-ctx ::=
;;   | #f
;;   | (for-loop [listof ir:for-clause] loop-ctx)
(struct for-loop (clauses up) #:transparent)

;; nat -> loop-ctx
(define (empty-loops depth)
  (for/fold ([cx #f]) ([_ (in-range depth)])
    (for-loop '() cx)))

;; loop-ctx loop-ctx -> loop-ctx
(define/match (merge-loops cx1 cx2)
  [{#f #f} #f]
  [{(for-loop fcs1 up1) (for-loop fcs2 up2)}
   (for-loop (append fcs1 fcs2)
             (merge-loops up1 up2))])

;; --------------------
;; metaterm -> ir
;; --------------------

(define (metaterm->ir initial-mt [fresh generate-temporary])

  ;; ir-kont = [ir:expr -> ir:expr]
  (define (id-kont x) x)

  (define outer-kont id-kont)
  (define (push! kont)
    (set! outer-kont (compose outer-kont kont)))

  ;; nat metaterm -> loop-ctx ir-kont [listof ir:expr]
  (define (anf depth mt)
    (match mt
      [(mt:unquoted stx spec)
       ; bind possibly-effectful syntax to temporary, and add contract check
       (define tmp-id (fresh))
       (push! (λ (r) (ir:bind tmp-id stx (ir:check tmp-id spec depth r))))
       ; create nested loop-ctx according to depth, something like:
       ; (for ([x0 stx]) (for ([x1 x0]) (for ([x2 x1]) ..)))
       (for/fold ([cx #f] [stx tmp-id] #:result (values cx id-kont (list stx)))
                 ([_ (in-range depth)])
         (define id* (fresh))
         (values (for-loop (list (ir:for-clause id* stx))
                           cx)
                 id*))]

      [(mt:datum stx spec)
       (define stx+q #`(quote #,stx))
       (push! (curry ir:check stx+q spec 0))
       (values (empty-loops depth)
               id-kont
               (list stx+q))]

      [(mt:prod prod body-mt)
       (define-values [cx kont exprs] (anf depth body-mt))
       (values cx kont (list (ir:prod prod exprs)))]

      [(mt:multiple cols)
       (let loop ([cols cols]) ; -> loop-ctx ir-kont [listof ir:expr]
         (match cols
           ['()
            (values (empty-loops depth)
                    id-kont
                    '())]

           [(cons mt* cols*)
            (define-values [cx1 kont1 exprs1] (anf depth mt*))
            (define-values [cx2 kont2 exprs2] (loop cols*))
            (values (merge-loops cx1 cx2)
                    (compose kont1 kont2)
                    (append exprs1 exprs2))]))]

      [(mt:build n-cols rows)
       (let loop ([rows rows]) ; -> loop-ctx ir-kont [listof ir:expr]
         (match rows
           ['()
            (values (empty-loops depth)
                    id-kont
                    (make-list n-cols ir:empty))]

           ; compile ellipsis into ir:for & ir:append
           [(cons (mt:e list-mt) rows*)
            (define-values [list-cx list-kont elems] (anf (add1 depth) list-mt))
            (match-define (for-loop for-clauses f-cx) list-cx)
            (define list-ids (map (λ (_) (fresh)) elems))
            (define elems* (ir:auto-values elems))
            (define f-kont (curry ir:for for-clauses (list-kont elems*) list-ids))
            (define-values [b-cx b-kont b-exprs] (loop rows*))
            (values (merge-loops f-cx b-cx)
                    (compose f-kont b-kont)
                    (map ir:auto-append list-ids b-exprs))]

           ; compile non-ellipsis elements into just ir:cons
           [(cons mt* rows*)
            (define-values [h-cx h-kont h-exprs] (anf depth mt*))
            (define-values [t-cx t-kont t-exprs] (loop rows*))
            (values (merge-loops h-cx t-cx)
                    (compose h-kont t-kont)
                    (map ir:cons h-exprs t-exprs))]))]))

  ;;;;;;;;;;;;;;;;

  (match-define-values [#f anf-kont (list expr)] (anf 0 initial-mt))
  (outer-kont (anf-kont expr)))

;; -------------
;; compile-template
;; -------------

;; syntax syntax language-repr-ids metaterm -> syntax
; Compile a metaterm into an expression producing a language term; for use
; in (template ..) or related macros.
(define (compile-template src-stx macro-head repr-ids mt)
  (let ir->stx ([ir (metaterm->ir mt)])
    (match ir
      [(ir:bind id rhs body)
       (quasisyntax/loc src-stx
         (let-values ([(#,id) #,rhs])
           #,(ir->stx body)))]
      [(ir:check stx spec depth body)
       (quasisyntax/loc src-stx
         (if (listof/depth '#,depth
                           #,(spec-predicate spec repr-ids)
                           #,stx)
           #,(ir->stx body)
           (raise-argument-error '#,macro-head
                                 '#,(spec-expectation-string depth spec)
                                 #,stx)))]
      [(ir:prod pr args)
       (define ctor-id (car (hash-ref (language-repr-ids-productions repr-ids) pr)))
       (quasisyntax/loc src-stx
         (#,ctor-id
          #,@(map ir->stx args)))]
      [(ir:cons h t)
       (quasisyntax/loc src-stx
         (cons #,(ir->stx h)
               #,(ir->stx t)))]
      [(ir:append f b)
       (quasisyntax/loc src-stx
         (append #,(ir->stx f)
                 #,(ir->stx b)))]
      [(ir:values es)
       (quasisyntax/loc src-stx
         (values #,@(map ir->stx es)))]
      [(ir:for for-clauses elem-expr out-ids body)
       (define/syntax-parse (id ...) (map ir:for-clause-id for-clauses))
       (define/syntax-parse (list ...) (map ir:for-clause-list-stx for-clauses))
       (quasisyntax/loc src-stx
         (let-values ([#,out-ids
                       (for/lists #,out-ids
                                  ([id (in-list list)] ...)
                         #,(ir->stx elem-expr))])
           #,(ir->stx body)))]
      [(? syntax? stx) stx])))

;; ----------------
;; helpers for contract checks
;; ----------------

(module listof/depth racket/base
  (provide listof/depth)
  ;; nat [any -> bool] any -> bool
  (define (listof/depth n f x)
    (if (zero? n)
      (f x)
      (or (null? x)
          (and (pair? x)
               (listof/depth (sub1 n) f (car x))
               (listof/depth n        f (cdr x)))))))

(require (for-template 'listof/depth))

;; spec language-repr-ids -> identifier
(define (spec-predicate spec repr-ids)
  (match spec
    [(? nonterminal-spec? nt)
     (hash-ref (language-repr-ids-predicates repr-ids) nt)]
    [(? terminal-spec? tm)
     (terminal-spec-contract-id tm)]))

;; spec depth -> string
(define (spec-expectation-string depth spec)
  (if (zero? depth)
    (match spec
      [(? nonterminal-spec? nt)
       (format "<nonterminal:~a>" (spec-description nt))]
      [(? terminal-spec? tm)
       (symbol->string (syntax-e (terminal-spec-contract-id tm)))])
    (format "(listof ~a)"
            (spec-expectation-string (sub1 depth) spec))))

;; =======================================================================================

(module+ test
  (require
   rackunit
   threading
   "../util/syntax.rkt"
   "../util/example-language-decls.rkt"
   "../syntax/metaterm.rkt"
   (submod ".." listof/depth))

  ;; listof/depth tests
  (check-true (listof/depth 0 integer? 5))
  (check-false (listof/depth 0 integer? 'x))
  (check-false (listof/depth 0 integer? '(1 0)))
  (check-false (listof/depth 1 integer? 5))
  (check-true (listof/depth 1 integer? '(1 0)))
  (check-false (listof/depth 2 integer? '(1 0)))
  (check-true (listof/depth 2 integer? '((1 0) () (2 3))))
  (check-false (listof/depth 2 integer? '((1 0) 0 (2 3))))

  ;; --------------

  ; Special gensym used for tests only
  (define (temps)
    (define i 0)
    (λ () (set! i (add1 i)) (format-id #'_ "tmp~a" i)))

  ;;;; Abbreviations

  (define (IR tm stx)
    (metaterm->ir (parse-mt tm L stx)
                  (temps)))

  ; (<~ (F ...) (G ...) (H ...) X) = (F ... (G ... (H ... X)))
  (define-match-expander <~
    (syntax-rules ()
      [(_ x) x]
      [(_ (f ...) x ...) (f ... (<~ x ...))]))

  ; (ir:list X Y Z) = (ir:cons X (ir:cons Y (ir:cons Z ir:empty)))
  (define-match-expander ir:list
    (syntax-rules ()
      [(_) (== ir:empty)]
      [(_ h t ...) (ir:cons h (ir:list t ...))]))

  ;;;; Ad-hoc new nonterminals

  (define mv-i (metavar #'i 'i))
  (define mv-x (metavar #'x 'x))

  ; [pt ::= (Point i i)]
  (define pr-Pt (production #'X 'Point (form-list #'X (list mv-i mv-i) #f '())))
  (define nt-pt (nonterminal-spec #'[pt ::=] '(pt) (list pr-Pt)))

  ; [tbl ::= (Tbl [x i] ...)
  (define pr-Tbl
    (~> (form-list #'X (list mv-x mv-i) #f '())
        (ellipsis _)
        (form-list #'X '() _ '())
        (production #'X 'Tbl _)))
  (define nt-tbl (nonterminal-spec #'[tbl ::=] '(tbl) (list pr-Tbl)))

  ; [mat ::= (Mat [i ...] ...)]
  (define pr-Mat
    (~> (form-list #'X '() (ellipsis mv-i) '())
        (ellipsis _)
        (form-list #'X '() _ '())
        (production #'X 'Mat _)))
  (define nt-mat
    (nonterminal-spec #'[mat ::=] '(mat) (list pr-Mat)))

  ;; ----------------

  ;; test unquote, datum
  (check-match (IR tm-i (quote-syntax 45))
               (<~ (ir:check (stx: '45) (== tm-i) 0)
                   (stx: '45)))

  (check-match (IR tm-xy (quote-syntax ,(some-expr)))
               (<~ (ir:bind (stx: tmp1) (stx: (some-expr)))
                   (ir:check (stx: tmp1) (== tm-xy) 0)
                   (stx: tmp1)))

  ;; test productions
  (check-match (IR nt-c (quote-syntax (C)))
               (ir:prod (== pr-C) '()))

  (check-match (IR nt-pt (quote-syntax (Point 3 4)))
               (<~ (ir:check (stx: '3) (== tm-i) 0)
                   (ir:check (stx: '4) (== tm-i) 0)
                   (ir:prod (== pr-Pt)
                            (list (stx: '3) (stx: '4)))))

  ;; test build
  (check-match (IR nt-ab (quote-syntax (B sym (C) ,some-c)))
               (<~ (ir:check (stx: 'sym) (== tm-xy) 0)
                   (ir:bind (stx: tmp1) (stx: some-c))
                   (ir:check (stx: tmp1) (== nt-c) 0)
                   (ir:prod (== pr-B))
                   (list (stx: 'sym) (ir:list (ir:prod (== pr-C) '())
                                              (stx: tmp1)))))

  ;; - ellipsis (simple)
  (check-match (IR nt-ab (quote-syntax (B sym ,c-list ...)))
               (<~ (ir:check (stx: 'sym) (== tm-xy) 0)
                   (ir:bind (stx: tmp1) (stx: c-list))
                   (ir:check (stx: tmp1) (== nt-c) 1)
                   (ir:for (list (ir:for-clause (stx: tmp2) (stx: tmp1)))
                           (stx: tmp2)
                           (list (stx: tmp3)))
                   (ir:prod (== pr-B)
                            (list (stx: 'sym) (stx: tmp3)))))

  ;; - ellipsis (parallel)
  (check-match (IR nt-tbl (quote-syntax (Tbl [,x* ,i*] ...)))
               (<~ (ir:bind (stx: tmp1) (stx: x*))
                   (ir:check (stx: tmp1) (== tm-xy) 1)
                   (ir:bind (stx: tmp3) (stx: i*))
                   (ir:check (stx: tmp3) (== tm-i) 1)
                   (ir:for (list (ir:for-clause (stx: tmp2) (stx: tmp1))
                                 (ir:for-clause (stx: tmp4) (stx: tmp3)))
                           ; loop expr:
                           (ir:values (list (stx: tmp2) (stx: tmp4)))
                           ; out ids:
                           (list (stx: tmp5) (stx: tmp6)))
                   ; body:
                   (ir:prod (== pr-Tbl)
                            (list (stx: tmp5)
                                  (stx: tmp6)))))

  ;; - ellipsis (higher ellipsis depth)
  (check-match (IR nt-mat (quote-syntax (Mat [,i** ...] ...)))
               (<~ (ir:bind (stx: tmp1) (stx: i**))
                   (ir:check (stx: tmp1) (== tm-i) 2)
                   (ir:for (list (ir:for-clause (stx: tmp2) (stx: tmp1)))
                           ; loop expr:
                           (ir:for (list (ir:for-clause (stx: tmp3) (stx: tmp2)))
                                   ; loop expr:
                                   (stx: tmp3)
                                   ; out ids:
                                   (list (stx: tmp4))
                                   ; body:
                                   (stx: tmp4))
                           ; out ids:
                           (list (stx: tmp5)))
                   ; body:
                   (ir:prod (== pr-Mat) (list (stx: tmp5)))))

  ;; - ellipsis (combined ellipsis depth)
  (check-match (IR nt-mat (quote-syntax (Mat [,i* ,i** ...] ...)))
               (<~ (ir:bind (stx: tmp1) (stx: i*))
                   (ir:check (stx: tmp1) (== tm-i) 1)
                   (ir:bind (stx: tmp3) (stx: i**))
                   (ir:check (stx: tmp3) (== tm-i) 2)
                   (ir:for (list (ir:for-clause (stx: tmp2) (stx: tmp1))
                                 (ir:for-clause (stx: tmp4) (stx: tmp3)))
                           ; loop expr:
                           (ir:for (list (ir:for-clause (stx: tmp5) (stx: tmp4)))
                                   ; loop expr:
                                   (stx: tmp5)
                                   ; out ids:
                                   (list (stx: tmp6))
                                   ; body:
                                   (ir:cons (stx: tmp2)
                                            (stx: tmp6)))
                           ; out ids:
                           (list (stx: tmp7)))
                   ; body:
                   (ir:prod (== pr-Mat) (list (stx: tmp7))))))
