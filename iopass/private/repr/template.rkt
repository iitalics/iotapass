#lang racket/base
(provide
 compile-template)

(require
 (prefix-in mt: "../ast/metaterm.rkt")
 "../ast/decl.rkt"
 "../repr/ids.rkt"
 (for-template racket/base)
 (only-in racket/syntax generate-temporary format-id)
 racket/list
 racket/match
 syntax/parse)

;; =======================================================================================

;; -------------
;; Intermediate representation for code generated by templates
;; -------------

;; ir ::=
;;   | (ir:let [listof ir:binding] ir:imm)
;;
;; ir:binding ::=
;;   | (ir:binding:protect id stx spec)
;;
;; ir:imm ::=
;;   | (ir:imm:mk production [listof ir:imm])
;;   | (ir:imm:vec [listof ir:imm])
;;   | id

(struct ir:let (bindings body) #:transparent)
(struct ir:binding:protect (id stx spec) #:transparent)
(struct ir:imm:mk (prod args) #:transparent)
(struct ir:imm:vec (elems) #:transparent)

;; metaterm -> ir
(define (metaterm->ir init-mt [fresh generate-temporary])

  ;; metaterm -> [listof ir:binding] [listof ir:imm]
  (define (anf mt)
    (match mt
      [(or (mt:unquoted stx spec)
           (mt:datum stx spec))
       (define id (fresh))
       (define the-stx (if (mt:datum? mt) #`(quote #,stx) stx))
       (values (list (ir:binding:protect id the-stx spec))
               (list id))]

      [(mt:prod prod body-mt)
       (define-values [bs is] (anf body-mt))
       (values bs (list (ir:imm:mk prod is)))]

      [(mt:multiple mts)
       ;; -> [listof ir:binding] [listof ir:imm]
       (let loop ([mts mts])
         (if (null? mts)
           (values '() '())
           (let-values ([(bs1 is1) (anf (car mts))]
                        [(bs2 is2) (loop (cdr mts))])
             (values (append bs1 bs2)
                     (append is1 is2)))))]

      [(mt:build n-cols rows)
       ;; -> [listof ir:binding] [listof [listof ir:imm]]
       (define-values [bs iss]
         (let loop ([rows rows])
           (if (null? rows)
             (values '() (make-list n-cols '()))
             (let-values ([(bs1 is) (anf (car rows))]
                          [(bs2 iss) (loop (cdr rows))])
               (values (append bs1 bs2)
                       (map cons is iss))))))
       (values bs (map ir:imm:vec iss))]))

  ;; ----

  (define-values [bs is] (anf init-mt))
  (ir:let bs (car is)))

;; -------------
;; compile-template
;; -------------

;; syntax syntax language-repr-ids metaterm -> syntax
; Compile a metaterm into an expression producing a language term; for use
; in (template ..) or related macros.
(define (compile-template src-stx macro-head repr-ids mt)

  ;; ir:binding -> syntax
  (define (ir:binding->let-values-clause b)
    (match b
      [(ir:binding:protect id rhs-stx spec)
       (quasisyntax/loc src-stx
         [(#,id)
          (protect-value '#,macro-head
                         #,(spec-predicate spec repr-ids)
                         '#,(spec-expectation-string spec)
                         #,rhs-stx)])]))

  (let ir->stx ([ir (metaterm->ir mt)])
    (match ir
      [(? syntax? stx) stx]
      [(ir:let bindings body)
       (quasisyntax/loc src-stx
         (let*-values (#,@(map ir:binding->let-values-clause bindings))
           #,(ir->stx body)))]
      [(ir:imm:mk pr args)
       (define ctor-id (car (hash-ref (language-repr-ids-productions repr-ids) pr)))
       (quasisyntax/loc src-stx
         (#,ctor-id
          #,@(map ir->stx args)))]
      [(ir:imm:vec elems)
       (quasisyntax/loc src-stx
         (vector-immutable #,@(map ir->stx elems)))])))

;; ----------------
;; helpers for protecting expressions with contracts
;; ----------------

(module protect-value-function racket/base
  (provide protect-value)
  ;; symbol [any -> bool | X] string any -> X
  (define (protect-value macro-head
                         predicate
                         expect-string
                         value)
    (if (predicate value)
      value
      (raise-argument-error macro-head expect-string value))))

(require (for-template 'protect-value-function))

;; spec language-repr-ids -> identifier
(define (spec-predicate spec repr-ids)
  (match spec
    [(? nonterminal-spec? nt)
     (hash-ref (language-repr-ids-predicates repr-ids) nt)]
    [(? terminal-spec? tm)
     (terminal-spec-contract-id tm)]))

;; spec -> string
(define (spec-expectation-string spec)
  (match spec
    [(? nonterminal-spec? nt)
     (format "nonterminal '~a'" (spec-description nt))]
    [(? terminal-spec? tm)
     (symbol->string (syntax-e (terminal-spec-contract-id tm)))]))

;; =======================================================================================

(module+ test
  (require
   rackunit
   "../util/syntax.rkt"
   "../util/example-language-decls.rkt"
   "../syntax/metaterm.rkt")

  ; special gensym used for tests only
  (define (temps)
    (define i 0)
    (Î» () (set! i (add1 i)) (format-id #'_ "tmp~a" i)))

  (define-syntax-rule (check-metaterm->ir spec mt-stx pattern)
    (check-match (metaterm->ir (parse-mt spec L mt-stx) (temps)) pattern))

  ; Pattern abbreviations
  (define-match-expander ir:let*
    (syntax-rules () [(_ bind ... bdy) (ir:let (list bind ...) bdyx)]))
  (define-match-expander ir:imm:mk*
    (syntax-rules () [(_ pr arg ...) (ir:imm:mk (== pr) (list arg ...))]))
  (define-match-expander ir:imm:vec*
    (syntax-rules () [(_ elem ...) (ir:imm:vec (list elem ...))]))

  ; Ad-hoc new nonterminal:
  ; [pt ::= (Point i i)]
  (define mv-i (metavar #'i 'i))
  (define pr-Pt (production #'_ 'Point (form-list #'() (list mv-i mv-i) #f '())))
  (define nt-pt (nonterminal-spec #'[pt ::=] '(pt) (list pr-Pt)))

  ;; ----------------

  ;; test unquote, datum
  (check-metaterm->ir tm-i
                      #'45
                      (ir:let* (ir:binding:protect (stx: tmp1) (stx: '45) (== tm-i))
                               (stx: tmp1)))
  (check-metaterm->ir tm-xy
                      #',(some-expr)
                      (ir:let* (ir:binding:protect (stx: tmp1) (stx: (some-expr)) (== tm-xy))
                               (stx: tmp1)))

  ;; test productions
  (check-metaterm->ir nt-c #'(C)
                      (ir:let* (ir:imm:mk* pr-C)))

  (check-metaterm->ir nt-pt #'(Point 3 4)
                      (ir:let* (ir:binding:protect (stx: tmp1) (stx: '3) (== tm-i))
                               (ir:binding:protect (stx: tmp2) (stx: '4) (== tm-i))
                               (ir:imm:mk* pr-Pt (stx: tmp1) (stx: tmp2))))

  ;; test build
  (check-metaterm->ir nt-ab
                      #'(B sym (C) ,some-c)
                      (ir:let* (ir:binding:protect (stx: tmp1)
                                                   (stx: 'sym)
                                                   (== tm-xy))
                               (ir:binding:protect (stx: tmp2)
                                                   (stx: some-c)
                                                   (== nt-c))
                               (ir:imm:mk* pr-B
                                           (stx: tmp1)
                                           (ir:imm:vec* (ir:imm:mk* pr-C)
                                                        (stx: tmp2))))))
